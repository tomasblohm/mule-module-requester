/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.module;

import java.util.Properties;

import javax.inject.Inject;

import org.mule.DefaultMessageCollection;
import org.mule.api.DefaultMuleException;
import org.mule.api.MuleContext;
import org.mule.api.MuleEvent;
import org.mule.api.MuleException;
import org.mule.api.MuleMessage;
import org.mule.api.MuleMessageCollection;
import org.mule.api.annotations.Category;
import org.mule.api.annotations.Module;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.api.context.MuleContextAware;
import org.mule.api.endpoint.EndpointBuilder;
import org.mule.api.endpoint.InboundEndpoint;
import org.mule.api.transformer.Transformer;
import org.mule.endpoint.MuleEndpointURI;
import org.mule.routing.MessageFilter;
import org.mule.transformer.types.DataTypeFactory;
import org.mule.transport.file.filters.FilenameWildcardFilter;

/**
 * Generic module
 * 
 * @author MuleSoft, Inc.
 */
@Module(name = "mulerequester", schemaVersion = "1.0-SNAPSHOT", friendlyName = "Mule Requester")
@Category(name = "org.mule.tooling.category.core", description = "Components") 
public class MuleRequesterModule implements MuleContextAware {
    
    private MuleContext muleContext;

    public void setMuleContext(MuleContext muleContext)
    {
          this.muleContext = muleContext;
    }

    /**
     * Request a resource from an address or endpoint. <br>
     * To make the request using the address, use the format "protocol://address". E.g.: "file://path/to/file". <br>
     * Otherwise, you can use a global endpoint name. E.g.: "fileEndpoint". <br>
     * 
     * {@sample.xml ../../../doc/MuleRequester-connector.xml.sample
     * mulerequester:request}
     * 
     * @param resource
     *            The address of the resource or the global endpoint name
     * @param timeout
     *            The timeout to wait for when requesting the resource
     * @param returnClass
     *            The return class to which this processor will transform the payload from the requested resource
     * @param throwExceptionOnTimeout
     *            Whether to throw an exception or not if no message is received in the configured timeout
     * @return a MuleMessage containing the requested resource as the payload
     * @throws MuleException Some exception
     */
    @Processor
    public Object request(String resource, @Optional @Default("1000") long timeout, @Optional String returnClass, @Optional Boolean throwExceptionOnTimeout) throws MuleException {
    	MuleEndpointURI endpointUri = new MuleEndpointURI(resource,muleContext);
		Properties params = endpointUri.getParams();
		EndpointBuilder endpointBuilder = muleContext.getEndpointFactory().getEndpointBuilder(resource);
		if (params.containsKey("fileNameFilter")) {
			endpointBuilder.addMessageProcessor(new MessageFilter(new FilenameWildcardFilter(params.getProperty("fileNameFilter"))));
		}
		InboundEndpoint inboundEndpoint = endpointBuilder.buildInboundEndpoint();
		MuleMessage message = null;
		try {
			message = inboundEndpoint.request(30000L);
		} catch (Exception e1) {
			throw new DefaultMuleException(e1.getMessage());
		}
    	Object result = null;
        if (message != null)
        {
            result = message.getPayload();
            if (returnClass != null) 
            {
                try {
                    Transformer transformer = muleContext.getRegistry().lookupTransformer(DataTypeFactory.create(result.getClass()), DataTypeFactory.create(Class.forName(returnClass)));
                    result = transformer.transform(result);
                } catch (ClassNotFoundException e) {
                    throw new DefaultMuleException(e);
                }
            }
            message.setPayload(result);
        } else if (Boolean.TRUE.equals(throwExceptionOnTimeout))
        {
            throw new DefaultMuleException("No message received in the configured timeout - " + timeout);
        }
        return message;
    }
    
    /**
     * Request a collection of resources from an address or endpoint. <br>
     * To make the request using the address, use the format "protocol://address". E.g.: "file://path/to/file". <br>
     * Otherwise, you can use a global endpoint name. E.g.: "fileEndpoint". <br>
     * 
     * {@sample.xml ../../../doc/MuleRequester-connector.xml.sample
     * mulerequester:request}
     * 
     * @param resource
     *            The address of the resource or the global endpoint name
     * @param timeout
     *            The timeout to wait for when requesting the resource
     * @param returnClass
     *            The return class to which this processor will transform the payload from the requested resource
     * @param throwExceptionOnTimeout
     *            Whether to throw an exception or not if no message is received in the configured timeout
     * @param count
     *            Number of resources to retrieve. Default is -1 (all resources available).
     * @param muleEvent MuleEvent
     * @throws MuleException Some exception
     */
    @Processor
    @Inject
    public void requestCollection(MuleEvent muleEvent, String resource, @Optional @Default("1000") long timeout, @Optional String returnClass,
    		@Optional Boolean throwExceptionOnTimeout, @Optional @Default("-1") int count) throws MuleException 
    {
    	final MuleMessageCollection resultCollection = new DefaultMessageCollection(muleContext);
    	boolean keepRequesting = count == -1 || count > 0;
    	int currentCount = 0;
    	while (keepRequesting)
    	{
    		MuleMessage message = muleContext.getClient().request(resource, timeout);
    		Object result;
    		if (message != null)
    		{
    			result = message.getPayload();
    			if (returnClass != null) 
    			{
    				try 
    				{
    					Transformer transformer = muleContext.getRegistry().lookupTransformer(DataTypeFactory.create(result.getClass()),
                                DataTypeFactory.create(Class.forName(returnClass)));
    					result = transformer.transform(result);
    				} 
    				catch (ClassNotFoundException e) 
    				{
    					throw new DefaultMuleException(e);
    				}
    			}
    			message.setPayload(result);
    			resultCollection.addMessage(message);
    			currentCount++;
    			keepRequesting = (count == -1 || currentCount < count);
    		} 
    		else
    		{
    			if (Boolean.TRUE.equals(throwExceptionOnTimeout))
    			{
    				throw new DefaultMuleException("No message received in the configured timeout - " + timeout);
    			}
    			else
    			{
    				keepRequesting = false;
    			}
    		}
    	}
        muleEvent.setMessage(resultCollection);
    }    
    
}
